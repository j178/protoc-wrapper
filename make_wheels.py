# /// script
# requires-python = ">=3.13"
# dependencies = [
#   "packaging>=25.0",
#   "requests>=2.32.3",
#   "semver>=3.0.4",
#   "wheel>=0.45.1",
# ]
# ///

import argparse
import hashlib
import io
import logging
import os
from pathlib import Path
from zipfile import ZipFile, ZipInfo

import requests
import semver
from packaging.version import Version as PyPIVersion
from wheel.wheelfile import WheelFile

PROTOC_PLATFORMS = {
    "linux-aarch_64": "manylinux_2_28_aarch64",
    "linux-ppcle_64": "manylinux_2_17_ppc64le.manylinux2014_ppc64le",
    "linux-s390_64": "manylinux_2_17_s390x.manylinux2014_s390x",
    "linux-x86_32": "manylinux_2_17_i686.manylinux2014_i686",
    "linux-x86_64": "manylinux_2_17_x86_64.manylinux2014_x86_64",
    "osx-aarch_64": "macosx_12_0_arm64",
    "osx-x86_64": "macosx_12_0_x86_64",
    "win32": "win32",
    "win64": "win_amd64",
}

MAIN_PY = """\
import os, sys

def main():
    argv = [os.path.join(os.path.dirname(__file__), "protoc"), *sys.argv[1:]]
    if os.name == "posix":
        os.execv(argv[0], argv)
    else:
        import subprocess
        sys.exit(subprocess.call(argv))


if __name__ == "__main__":
    main()
"""

METADATA = """\
Metadata-Version: 2.4
Name: protoc-wrapper
Version: {version}
Summary: Repackage official protoc compiler as Python wheels
Keywords: protobuf,protoc
Author: j178
Author-email: j178 <10510431+j178@users.noreply.github.com>
License-Expression: MIT
Classifier: Development Status :: 4 - Beta
Classifier: Environment :: Console
Classifier: Intended Audience :: Developers
Classifier: Operating System :: OS Independent
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: Programming Language :: Python :: 3.13
Classifier: Programming Language :: Python :: 3 :: Only
Classifier: Topic :: Software Development :: Code Generators
Requires-Python: >=3.8
Project-URL: Releases, https://github.com/j178/protoc-wrapper/releases
Project-URL: Repository, https://github.com/j178/protoc-wrapper
Description-Content-Type: text/markdown

{description}
"""

LICENSE = """\
Copyright 2008 Google Inc.  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the following disclaimer
in the documentation and/or other materials provided with the
distribution.
    * Neither the name of Google Inc. nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Code generated by the Protocol Buffer compiler is owned by the owner
of the input file used when generating it.  This code is not
standalone and requires a support library to be linked with it.  This
support library is itself covered by the above license.
"""

session = requests.Session()
if token := os.environ.get("GITHUB_TOKEN"):
    session.headers.update({"Authorization": f"Bearer {token}"})


def write_wheel_file(
    out_dir: str,
    version: str,
    tag: str,
    metadata: str,
    description: str,
    contents: dict[str | ZipInfo, bytes],
) -> str:
    wheel_name = f"protoc_wrapper-{version}-{tag}.whl"
    dist_info = f"protoc_wrapper-{version}.dist-info"

    contents[f"{dist_info}/entry_points.txt"] = b"""\
[console_scripts]
protoc = protoc_wrapper.__main__:main
protoc-wrapper = protoc_wrapper.__main__:main
"""
    contents[f"{dist_info}/METADATA"] = metadata.format(
        version=version, description=description
    ).encode()
    contents[f"{dist_info}/WHEEL"] = f"""\
Wheel-Version: 1.0
Generator: protoc_wrapper make_wheels.py
Root-Is-Purelib: false
Tag: {tag}
""".encode()
    contents[f"{dist_info}/licenses/LICENSE"] = LICENSE

    path = os.path.join(out_dir, wheel_name)
    with WheelFile(path, "w") as wheel:
        for member_info, member_source in contents.items():
            wheel.writestr(member_info, member_source)

    return path


def write_protoc_wheel(
    out_dir: str, version: str, platform: str, archive: bytes
) -> str:
    contents = {}
    contents["protoc_wrapper/__init__.py"] = b""
    contents["protoc_wrapper/__main__.py"] = MAIN_PY.encode("utf-8")

    with ZipFile(io.BytesIO(archive)) as zip_file:
        for entry in zip_file.infolist():
            if entry.filename.startswith("bin/"):
                entry_name = entry.filename[4:]
                entry_data = zip_file.read(entry.filename)

                zip_info = ZipInfo(f"protoc_wrapper/{entry_name}")
                zip_info.external_attr = entry.external_attr
                contents[zip_info] = entry_data

    with open("README.md") as f:
        description = f.read()

    return write_wheel_file(
        out_dir,
        version=version,
        tag=f"py3-none-{platform}",
        metadata=METADATA,
        description=description,
        contents=contents,
    )


def to_pypi_version(ver: str) -> PyPIVersion:
    """Converts a semver version into a version from PyPI

    A semver prerelease will be converted into a prerelease of PyPI.
    A semver build will be converted into a development part of PyPI.
    """
    if ver.count(".") == 1:
        parts = ver.split("-")
        ver = parts[0] + ".0"
        if len(parts) > 1:
            ver += f"-{parts[1]}"

    ver = semver.Version.parse(ver)
    v = ver.finalize_version()
    prerelease = ver.prerelease if ver.prerelease else ""
    build = ver.build if ver.build else ""
    return PyPIVersion(f"{v}{prerelease}{build}")


def get_latest_version() -> str:
    url = "https://api.github.com/repos/protocolbuffers/protobuf/releases?per_page=1"
    resp = session.get(url)
    data = resp.json()
    return data[0]["tag_name"]


def write_wheels(
    outdir: str,
    version: str,
    platforms: list[str] | None = None,
):
    Path(outdir).mkdir(exist_ok=True)
    if not platforms:
        platforms = list(PROTOC_PLATFORMS)

    # TODO: handle "latest" version
    if version == "latest":
        version = get_latest_version()
    version = version.removeprefix("v")
    wheel_version = to_pypi_version(version)

    for platform in platforms:
        # "30.0-rc1" to "30.0-rc-1"
        version_in_filename = version
        if "rc" in version:
            version_in_filename = version.replace("-rc", "-rc-")
        url = f"https://github.com/protocolbuffers/protobuf/releases/download/v{version}/protoc-{version_in_filename}-{platform}.zip"

        python_platform = PROTOC_PLATFORMS[platform]

        logging.info(f"Fetching {url} for {python_platform} ({wheel_version})")
        resp = session.get(url)

        wheel_path = write_protoc_wheel(
            outdir,
            version=str(wheel_version),
            platform=python_platform,
            archive=resp.content,
        )
        with open(wheel_path, "rb") as wheel:
            digest = hashlib.sha256(wheel.read()).hexdigest()
            print(f"  {digest} {wheel_path}")


def get_argparser():
    parser = argparse.ArgumentParser(
        prog=__file__, description="Repackage official protoc compiler as Python wheels"
    )
    parser.add_argument(
        "--version",
        default="latest",
        help="version to package, use `latest` for latest release",
    )
    parser.add_argument("--outdir", default="dist/", help="target directory")
    parser.add_argument(
        "--platform",
        action="append",
        choices=list(PROTOC_PLATFORMS.keys()),
        default=[],
        help="platform to build for, can be repeated",
    )
    return parser


def main():
    args = get_argparser().parse_args()
    logging.getLogger("wheel").setLevel(logging.WARNING)
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s %(levelname)s %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S",
    )
    write_wheels(
        outdir=args.outdir,
        version=args.version,
        platforms=args.platform,
    )


if __name__ == "__main__":
    main()
